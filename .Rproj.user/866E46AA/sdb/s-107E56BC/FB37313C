{
    "collab_server" : "",
    "contents" : "#Creates stx1 as xts object containing variables as defined in v.com for current stock\n#Requires res, ret, cmn, logadv.z (bin variable) to be previously computed for current stock\n\nmk_vars_fun <- function(v.com, res, ret, cmnret, logadv.z, adjv, cmnpvars) {\n  require(dplyr)\n  tier1 <- 1:length(v.com)\n  tier_v <- list(tier1)    #future requirement when variable creation has to be ordered\n  \n  stx1.data <- NULL #res[,substr(predict.ret,1,2)]\n  oos1.data <- NULL\n  for (tier_n in 1:length(tier_v)) {\n    v_list <- tier_v[[tier_n]]\n    for (v_n in v_list) {\n      #print(paste(tier_n,v_n))\n      vc <- v.com[[v_n]]\n      #print(names(v.com)[v_n])\n      if (all(vc$var != \"vol\")) {  # 'all' so that NULL values will evaluate to TRUE (NULL -> \"ret\")\n        switch(vc$type,\n               \"res\" = stx1.var1 <- res[,vc$retnam],\n               \"ret\" = stx1.var1 <- ret[,vc$retnam],\n               \"cmn\" = stx1.var1 <- cmnret[,vc$retnam],\n               {print(paste(v_n,\"Type not found\"))\n                 next}\n        )\n      }\n      if (!is.null(vc$var)) {\n        switch(vc$var,\n               \"ret\" = {}, #no action, default\n               \"vol\" = {\n                 switch(vc$type,\n                        \"res\" = {  #ratio of stx dolvol to cmn dolvol\n                          vdf <- cbind(adjv[,\"D\"],cmnpvars[,\"D\"])\n                          colnames(vdf) <- c(\"retD\",\"cmnD\")\n                          stx1.var1 <- calc_volres(vdf)\n                        },  \n                        \"ret\" = {  #ratio of stx dolvol to stx adv\n                          stx1.var1 <- calc_voladv(adjv[,\"D\"])  \n                        },\n                        \"cmn\" = {  #ratio of cmn dolvol to cmn adv\n                          stx1.var1 <- calc_voladv(cmnpvars[,\"D\"])  \n                        }\n                 )\n                 if (!is.null(vc$log)) stx1.var1 <- log(stx1.var1) #convert ratios to log\n               },\n               \"vlt\" = stx1.var1 <- calc_vlt(stx1.var1)\n        )\n      }\n      if (!is.null(vc$cap)) {\n        if (vc$cap > 0) stx1.var1 <- calc_cap(stx1.var1,vc$cap)\n      }\n      if (!is.null(vc$scale)) {\n        switch(vc$scale,\n               \"zscore\" = stx1.var1 <- calc_z(stx1.var1,ma=TRUE),\n               \"zscale\" = stx1.var1 <- calc_z(stx1.var1,ma=FALSE),\n               print(\"No scaling\"))\n      }\n      if (!is.null(vc$bin_var)) {\n        colnames(stx1.var1) <- names(v.com)[v_n]\n        stx1.var1 <- calc_bin(stx1.var1,eval(as.name(vc$bin_var)),vc$b1,vc$b2)\n      }\n      if (!is.null(vc$decay)) {\n        if (vc$decay > 0) stx1.var1 <- calc_decay(stx1.var1,d=vc$decay)\n      }\n      if (!is.null(vc$lag)) {\n        if (vc$lag > 0) stx1.var1 <- calc_lag(stx1.var1,vc$lag)\n      }\n      if (ncol(stx1.var1) == 1) colnames(stx1.var1) <- names(v.com)[v_n]\n      #if (verbose) print(colnames(stx1.var1))\n      if (is.null(stx1.data)) {\n        #stx1.data <- as.data.frame(index(stx1.var1))\n        #stx1.data[,2] <- rep(nam, nrow(stx1.var1))\n        #colnames(stx1.data) <- c(\"date\",\"TICKER\")\n        stx1.data <- stx1.var1\n      } else {\n        stx1.data <- merge(stx1.data,stx1.var1)\n      }\n    }  \n  }\n  return(stx1.data)\n}  \n\nmake_adj <- function(df,field,cnam,adjcnam) {\n  adj_var <- df[,field] * df[,adjcnam] / df[,cnam]\n  return(adj_var)\n}\n\ncalc_adj <- function(df,nam) {\n  adj_fields <- c(paste(nam,\".Open\",sep=\"\"),paste(nam,\".High\",sep=\"\"),paste(nam,\".Low\",sep=\"\"))\n  cnam <- paste(nam,\".Close\",sep=\"\")\n  adjcnam <- paste(nam,\".Adjusted\",sep=\"\")\n  adj_vars <- NULL\n  for (i in adj_fields) {\n    adj_var <- make_adj(df,i,cnam,adjcnam)\n    adj_vars <- cbind(adj_vars,adj_var)\n  }\n  volnam <- paste(nam,\".Volume\",sep=\"\")\n  adj_vars <- cbind(adj_vars,df[,adjcnam],df[,volnam])\n  colnames(adj_vars) <- c(\"O\",\"H\",\"L\",\"C\",\"V\")\n  #calc M\n  adj_var <- sqrt(adj_vars[,\"H\"]*adj_vars[,\"L\"])\n  adj_vars <- cbind(adj_vars,adj_var)\n  colnames(adj_vars)[ncol(adj_vars)] <- \"M\"\n  #calc D (dollars = M*V)\n  adj_var <- adj_vars[,\"V\"]*adj_vars[,\"M\"]\n  adj_vars <- cbind(adj_vars,adj_var)\n  colnames(adj_vars)[ncol(adj_vars)] <- \"D\"\n  return(adj_vars)\n}\n\ncalc_lag <- function(df,n=1,rename=FALSE) {\n  lag_vars <- stats::lag(df,n)\n  if (rename) {\n    if (n==1) {\n      lag_str <- \"Y\"\n    } \n    else {\n      lag_str <- paste(\"Y\",n,sep=\"\")\n    }\n    colnames(lag_vars) <- paste(lag_str,colnames(lag_vars),sep=\"\")\n  }\n  return(lag_vars)\n}\n\ncalc_rets <- function(df) {\n  ret_formulas = matrix(c(\n    \"CC\",\"YC\",\"C\",\n    \"CO\",\"YC\",\"O\",\n    \"OC\",\"O\",\"C\",\n    \"MC\",\"M\",\"C\",\n    \"LH\",\"L\",\"H\"),\n    nrow = 5,\n    ncol = 3,\n    byrow = TRUE)\n  colnames(ret_formulas) <- c(\"name\",\"sprice\",\"eprice\")\n  ret_vars <- NULL\n  for (i in 1:nrow(ret_formulas)) {\n    ret_f <- ret_formulas[i,]\n    ret_var <- log(df[,ret_f[3]]/df[,ret_f[2]])\n    colnames(ret_var) <- ret_f[1]\n    ret_vars <- cbind(ret_vars,ret_var)\n  }\n  ret_vars <- subset(ret_vars,!is.na(ret_vars[,substr(predict.ret,1,2)])) #remove observations where predict var is NA\n  return(ret_vars)\n}\n\ncalc_vol <- function(df,window=20) {\n  df.adv <- xts(apply(df,2,runMean,n=window), index()) \n      df.vlt <- xts(apply(df,2,runSD,n=window), index(df))*sqrt(252)\n\n}\n\n\ncalc_cap_pct <- function(df, low, high, lb = 0) {\n  #only works for all data [lookback == 0], need to code longer lookbacks\n  #print(paste(low,high))\n  qs <- sapply(df,function(z) quantile(z,c(low,high),na.rm = TRUE))\n  #print(qs)\n  df.cap.val <- NULL\n  for (i in 1:ncol(df)) {\n    col.data <- as.xts(df[,i])\n    col.data[col.data < qs[1,i]] <- qs[1,i]\n    col.data[col.data > qs[2,i]] <- qs[2,i]\n    df.cap.val <- cbind(df.cap.val,col.data)\n  }\n  return(df.cap.val)\n}\n\ncalc_cap_val <- function(df, low, high) {\n  df.cap.val <- df\n  df.cap.val[df.cap.val < low] <- low\n  df.cap.val[df.cap.val > high] <- high\n  return(df.cap.val)\n}\n\n\ncalc_cap <- function(df, cap = NA, pct = TRUE, low = NA, high = NA, lb = 0) {\n  #check parameters\n  if (is.na(cap) & (is.na(low) | is.na(high)) ) {\n    print(\"Error: cap or low/high must be set\")\n    return(-1)\n  }\n  if (pct) {\n    if (is.na(cap)) {\n      if (low < -1 | low >= 1 | high <= -1 | high > 1) {\n        print(\"Error: Low and High have to be pcts (otherwise set pct = FALSE)\")\n        return(-1)\n      }\n    }\n    else {\n      if (cap < 0 | cap > 1 ) {\n        print (\"Error: Cap has to be pcts (otherwise set pct = FALSE)\")\n        return(-1)\n      }\n    }\n  } #pct\n  #set low/high if needed  \n  if (!is.na(cap) & pct) {\n    low <- cap\n    high <- 1-cap\n  }  \n  else {\n    if (!is.na(cap) & !pct) {\n    low <- -cap\n    high <- cap\n    }\n  }\n  if (pct) {\n    df.cap <- calc_cap_pct(df,low,high,lb)\n  }  \n  else {\n    df.cap <- calc_cap_val(df,low,high)\n  }\n  return(df.cap)  \n}\n\ncalc_decay <- function(df,d,rename=FALSE) {\n  require(forecast)\n  df.decay <- NULL\n  for (i in 1:ncol(df)) {\n    #print(paste(i,colnames(df)[i]))\n    col.data <- as.xts(df[,i])\n    #replace NA with 0\n    col.data[is.na(col.data)] <- 0\n    col.ses <- ses(col.data,alpha=d)\n    col.decay <- xts(fitted.values(col.ses),order.by = index(col.data))\n    df.decay <- cbind(df.decay,col.decay)\n  }\n  if (rename) colnames(df.decay) <- paste(colnames(df),\"d\",100*d,sep=\"\")\n  else colnames(df.decay) <- colnames(df)\n\n  return(df.decay)\n}\n\ncalc_z <- function(df,ma = TRUE, window = 60, cap = 0) {\n  #pct_cap on the st.dev. not yet supported\n\n  #if required to not use future information (uses only historic information in window)\n  #df.sd <-xts(apply(df,2,runSD,n=window), index(df))\n  #if (ma) {\n  #  df.mean <- xts(apply(df,2,runMean,n=window), index(df))\n  #  df.zscore <- (df-df.mean)/df.sd\n  #} else {\n  #  df.zscore <- df/df.sd\n  #}\n  df.zscore <- scale(df,center=ma)\n  return(df.zscore)\n}\n\ncalc_vlt <- function(df,window=60) {\n  df.vlt <- xts(apply(df,2,runSD,n=window), index(df))\n  df.vlt <- lag(df.vlt,1) \n  df.vlt <- df.vlt*df.vlt #vlt = sd*sd\n  colnames(df.vlt) <- paste(colnames(df.vlt),\"vlt\",sep=\"\")\n  return(df.vlt)\n}\n\ncalc_vol <- function(df,window=20) {\n  df.adv <- runMean(df,n=window,cumulative=FALSE)\n  df.logadv <- log(df.adv)\n  df.ratio <- df / df.adv\n  df.vol <- cbind(df,df.adv,df.logadv,df.ratio)\n  df.vol <- lag(df.vol,1)\n  colnames(df.vol) <- c(paste(\"Y\",colnames(df),sep=\"\"),paste(\"AD\",colnames(df),window,sep=\"\"),\n                        paste(\"AD\",colnames(df),\"log\",sep=\"\"),paste(colnames(df),\"rat\",sep=\"\"))\n  return(df.vol)\n}\n\ncalc_bin <- function(var,bin_var,b1=-2.,b2=2) {\n    v.temp <- na.exclude(merge(var,bin_var))\n    x <- c(b1,b2)\n    y <- c(1,0)\n    vl <- v.temp[,names(var)]*approx(x,y,v.temp[,names(bin_var)],yleft=1,yright=0)$y\n    y <- c(0,1)\n    vh <- v.temp[,names(var)]*approx(x,y,v.temp[,names(bin_var)],yleft=0,yright=1)$y\n    v.out <- cbind(vl,vh)\n    naml <- paste(names(var),\".\",abs(trunc(10*b1)),abs(trunc(10*b2)),\"l\",sep=\"\")\n    namh <- paste(names(var),\".\",abs(trunc(10*b1)),abs(trunc(10*b2)),\"h\",sep=\"\")\n    colnames(v.out) <- c(naml,namh)\n  return(v.out)\n}\n\ncalc_volres <- function(df) {  #assumes df has two columns, retD / cmnD, daily dollar volumes of stx and cmn\n  vol_ratio <- df[,\"retD\"]/df[,\"cmnD\"]\n  return(vol_ratio)\n}\n\ncalc_voladv <- function(df,window=20) { #assumes df contains single column of Volume\n  df.adv <- runMean(df,n=window,cumulative=FALSE)\n  vol_ratio <- df / df.adv\n  return(vol_ratio)\n}\n\n",
    "created" : 1479942348576.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2420837057",
    "id" : "FB37313C",
    "lastKnownWriteTime" : 1479955863,
    "last_content_update" : 1479955863938,
    "path" : "~/XLF/pred_opt_sim/calc_func.R",
    "project_path" : "calc_func.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}