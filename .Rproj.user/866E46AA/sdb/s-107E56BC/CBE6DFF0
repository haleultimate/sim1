{
    "collab_server" : "",
    "contents" : "#make into function\n#pass in mu, vlty, port_size\n#future: add in order vars (take into account order costs)\n\nport_opt_lp <- function (lp.mu, lp.vlty, lp.port_size) {\n  \n  if (!exists(\"lp.first_run\")) {\n    lp.first_run <- FALSE\n    lp.old_port_size <- (-1)\n    lp.stx <- length(lp.mu)\n    if (lp.stx != length(lp.vlty)) print (\"ERROR: MU and VLTY must have same number of stocks\")\n    \n    lp.vlty_bounds <- c(0,10000,15000,25000)\n    vb_n <- length(lp.vlty_bounds)    #number of vlty bounds\n    lp.vbs <- vb_n - 2                #number of vlty bound segments needing variables\n    max_vb <- lp.vlty_bounds[vb_n]    #upper positions size constraint\n    \n    #create random u and v vectors\n    #mu <- rnorm(lp.stx,0,.0050)\n    #vlty <- rnorm(lp.stx,0.015,.0025)\n    #vlty <- vlty*vlty\n    \n    lp.alpha_wt <- 2000.\n    lp.vlty_wt <- rep(-1.,vb_n-1)\n    \n    pos_vars <- lp.stx                #position (only var allowed to go negative)\n    long_short_vars <- 2*lp.stx       #long, short (abs of position)\n    vb_vars <- lp.vbs*lp.stx             #volatility bound segments (2..vb_n-1)  #first segment uses long/short vars\n    \n    # 1:lp.stx                        # pos_vars\n    # (lp.stx+1):(2*lp.stx)              # long_vars\n    # (2*lp.stx+1):(3*lp.stx)            # short_vars\n    # (3*lp.stx+1):(3*lp.stx+vbi*lp.stx)    # vb_vars (one for every lp.stx for each lp.vlty_bounds segment)\n    lp.vars <- pos_vars + long_short_vars + vb_vars\n    \n    unique_cons <- 3               #port_size (1), long_short balance (2)\n    long_short_cons <- long_short_vars\n    vb_cons <- 2*vb_vars           #each variable defined long/short\n    \n    cons <- unique_cons + long_short_cons + vb_cons\n    \n    #init lp.port.model\n    lp.port.model <- make.lp(nrow=0,ncol=lp.vars)\n    lp.control(lp.port.model,sense=\"max\")\n    \n    \n    set.bounds(lp.port.model,lower=c(rep(-max_vb,lp.stx),rep(0,(lp.vars-lp.stx))),columns=(1:lp.vars))\n    set.bounds(lp.port.model,upper=rep(max_vb,(3*lp.stx)),columns=(1:(3*lp.stx)))\n    for (vb_i in 1:lp.vbs) {\n      max_vbs <- max_vb - lp.vlty_bounds[vb_i+1]\n      set.bounds(lp.port.model,upper=rep(max_vbs,lp.stx),columns=((3*lp.stx+(vb_i-1)*lp.stx+1):(3*lp.stx+vb_i*lp.stx)))\n    }\n    add.constraint(lp.port.model,c(rep(0,lp.stx),rep(1,2*lp.stx),rep(0,(lp.vars-3*lp.stx))),\"=\",lp.port_size)\n    add.constraint(lp.port.model,c(rep(1,lp.stx),rep(0,(lp.vars-lp.stx))),\"=\",0)\n    add.constraint(lp.port.model,c(rep(0,lp.stx),rep(1,lp.stx),rep(-1,lp.stx),rep(0,lp.vars-3*lp.stx)),\"=\",0)\n    #L[1:lp.stx]\n    for (var_i in 1:lp.stx) {\n      add.constraint(lp.port.model,xt=c(1,-1),type=\"<=\",rhs=0,indices=c(var_i,lp.stx+var_i))\n    }\n    #S[lp.stx]\n    for (var_i in 1:lp.stx) {\n      add.constraint(lp.port.model,xt=c(1,1),type=\">=\",rhs=0,indices=c(var_i,2*lp.stx+var_i))\n    }\n    #VB[1:lp.vbs]L[1:lp.stx]\n    #VB[1:lp.vbs]S[1:lp.stx]\n    for (vb_i in 1:lp.vbs) {\n      for (var_i in 1:lp.stx) {                                                              #long var\n        add.constraint(lp.port.model,xt=c(1,-1),type=\"<=\",rhs=lp.vlty_bounds[vb_i+1],indices=c((lp.stx+var_i),((3+vb_i-1)*lp.stx+var_i)))\n      }\n      for (var_i in 1:lp.stx) {                                                              #short var\n        add.constraint(lp.port.model,xt=c(1,-1),type=\"<=\",rhs=lp.vlty_bounds[vb_i+1],indices=c((2*lp.stx+var_i),((3+vb_i-1)*lp.stx+var_i)))\n      }\n    }\n    \n    nums <- 1:lp.stx\n    col_chars <- c(\"P\",\"L\",\"S\")\n    for (vb_i in 1:lp.vbs) {\n      col_chars <- c(col_chars,paste(\"VB\",vb_i+1,\"_\",sep=\"\"))\n    }\n    var_names <- NULL\n    for (char in 1:length(col_chars)) {\n      var_names <- c(var_names,paste(col_chars[char],nums,sep=\"\"))\n    }\n    \n    con_chars <- c(\"L\",\"S\")\n    for (vb_i in 1:lp.vbs) {\n      con_chars <- c(con_chars,paste(\"VB\",vb_i+1,\"L\",sep=\"\"))\n      con_chars <- c(con_chars,paste(\"VB\",vb_i+1,\"S\",sep=\"\"))\n    }\n    con_names <- c(\"port_size\",\"ls_balance1\",\"ls_balance2\")\n    for (char in 1:length(con_chars)) {\n      con_names <- c(con_names,paste(con_chars[char],nums,sep=\"\"))\n    }  \n    dimnames(lp.port.model) <- list(con_names,var_names)\n  }\n\n  #set objective function, needed for every new MU, VLTY\n  lp.obj.fun <- rep(0,lp.vars)\n  #mu component\n  lp.obj.fun[1:lp.stx] <- lp.alpha_wt*lp.mu\n  #first vlty segment\n  lp.obj.fun[(lp.stx+1):(2*lp.stx)]   <- lp.vlty_wt[1]*lp.vlty_bounds[2]*lp.vlty\n  lp.obj.fun[(2*lp.stx+1):(3*lp.stx)] <- lp.obj.fun[(lp.stx+1):(2*lp.stx)]\n  #subsequent vlty segments\n  for (vb_i in 1:lp.vbs) { #piecwise linear component for segment (portion added to all previous segments)\n    lp.obj.fun[(3*lp.stx+(vb_i-1)*lp.stx+1):(3*lp.stx+vb_i*lp.stx)] <- lp.vlty_wt[vb_i+1]*lp.vlty_bounds[vb_i+2]*lp.vlty\n  }\n  set.objfn(lp.port.model,lp.obj.fun)\n  #set port_size constraint, needed for every new port_size\n  if (lp.port_size != lp.port_size) {\n    #add.constraint(port.model,c(rep(0,lp.stx),rep(1,2*lp.stx),rep(0,(lp.vars-3*lp.stx))),\"=\",lp.port_size)\n    set.rhs(lp.port.model,b=lp.port_size,constraints=1) #can I use the constraint name = \"port_size\" here?\n  }\n  \n  if (verbose) write.lp(lp.port.model,filename=\"test_lp\",type=\"lp\")\n  \n  solve(lp.port.model)\n  lp.positions <- get.variables(lp.port.model)[1:lp.stx]\n\n  if(verbose) {\n    pos_sqr <- lp.positions*lp.positions\n  \n    calc_mu <- lp.positions*lp.mu*lp.alpha_wt\n    calc_vlty <- pos_sqr*lp.vlty\n  \n    total_mu <- sum(calc_mu)\n    total_vlty <- sum(calc_vlty)\n  \n    print(lp.positions)\n    print(lp.mu)\n    print(lp.vlty)\n  \n    print(paste(\"total mu=\",total_mu,\"total vlty=\",total_vlty))\n    print(total_mu-total_vlty)\n    print(get.objective(lp.port.model))\n  }  \n  return(lp.positions)\n}  ",
    "created" : 1479965389449.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3677993270",
    "id" : "CBE6DFF0",
    "lastKnownWriteTime" : 1480276421,
    "last_content_update" : 1480276421026,
    "path" : "~/XLF/pred_opt_sim/port_opt.R",
    "project_path" : "port_opt.R",
    "properties" : {
        "source_window_id" : ""
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}